<!doctype html>

<script type=module>

  import { Tile } from "./tile.js";

  // const tilejson = await (await fetch("https://d1zqyi8v6vm8p9.cloudfront.net/planet.json")).json();

  const doFetch = async (...request) => {
    const response = await fetch(...request);
    if (!response.ok) throw new Error(response.status);
    return response;
  };

  /*
  const json = async (...request) => (await doFetch(...request)).json();
  const arrayBuffer = async (...request) => (await doFetch(...request)).arrayBuffer();
  const text = async (...request) => (await doFetch(...request)).text();
  const blob = async (...request) => (await doFetch(...request)).blob();
  */

  const fetchTile = async (...request) => {
    const gunzip = new DecompressionStream("gzip");
    const gz = await doFetch(...request);
    const raw = await new Response(gz.body.pipeThrough(gunzip)).arrayBuffer();
    return new Uint8Array(raw);
  };

  const tiledata = await fetchTile("tile.gz");
  console.log('tiledata =', window.tiledata = tiledata);

  const tile = Tile.parseFrom(tiledata);
  console.log('tile =', window.tile = tile);

  import { path as geoPath } from "./path.js";
  const cx = document.createElement("canvas").getContext("2d");
  document.body.append(cx.canvas);
  const tileSize = 512;
  Object.assign(cx.canvas, { width: tileSize, height: tileSize });
  const path = geoPath().context(cx);
  for (const k of Object.keys(tile.layers)) {
    const layer = tile.layers[k];
    const scale = tileSize / layer.extent;
    cx.save();
    cx.scale(scale, scale);
    path.pointRadius(4.5 / scale);
    cx.lineWidth = layer.extent / cx.canvas.width;
    for (const feature of layer) {
      const g = feature.toGeoJSON();
      cx.beginPath();
      path(g);
      cx.stroke();
      if (["Polygon", "MultiPolygon"].includes(g.type)) {
        cx.fillStyle='#c0c0c044';
        cx.fill();
      }
    }
    cx.restore();
  }

</script>
