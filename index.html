<!doctype html>

<script type=module>

  import { Tile } from "./tile.js";

  // const tilejson = await (await fetch("https://d1zqyi8v6vm8p9.cloudfront.net/planet.json")).json();

  const doFetch = async (...request) => {
    const response = await fetch(...request);
    if (!response.ok) throw new Error(response.status);
    return response;
  };

  /*
  const json = async (...request) => (await doFetch(...request)).json();
  const arrayBuffer = async (...request) => (await doFetch(...request)).arrayBuffer();
  const text = async (...request) => (await doFetch(...request)).text();
  const blob = async (...request) => (await doFetch(...request)).blob();
  */

  const fetchTile = async (...request) => {
    const gunzip = new DecompressionStream("gzip");
    const gz = await doFetch(...request);
    const raw = await new Response(gz.body.pipeThrough(gunzip)).arrayBuffer();
    return new Uint8Array(raw);
  };

  const tiledata = await fetchTile("tile.gz");
  console.log('tiledata =', window.tiledata = tiledata);

  const tile = Tile.parseFrom(tiledata);
  console.log('tile =', window.tile = tile);

  import * as d3 from "https://esm.run/d3";
  const cx = document.createElement("canvas").getContext("2d");
  document.body.append(cx.canvas);
  Object.assign(cx.canvas, { width: 512, height: 512 });
  const path = d3.geoPath().context(cx);
  for (const k of Object.keys(tile.layers)) {
    const layer = tile.layers[k];
    cx.save();
    cx.scale(
      cx.canvas.width / layer.extent,
      cx.canvas.height / layer.extent,
    );
    cx.lineWidth = layer.extent / cx.canvas.width;
    for (const feature of layer) {
      const g = feature.toGeoJSON();
      cx.beginPath();
      path(g);
      cx.stroke();
      if (["Polygon", "MultiPolygon"].includes(g.type)) {
        cx.fillStyle='#c0c0c044';
        cx.fill();
      }
      const name = feature.properties["name:en"] ?? feature.properties.name;
      if (g.type === "Point" && name) {
        cx.font = `${layer.extent / cx.canvas.width}em serif`;
        cx.fillText(name, g.coordinates[0], g.coordinates[1]);
      }
    }
    cx.restore();
  }

</script>
